<!-- rstumm2s -->
<article>
    <style>
    .chart-container {
        position: relative;
        height: 50vh;
    }
    </style>

    <section class="chart-container">
        <script src="https://cdn.jsdelivr.net/npm/moment@2.20.1/min/moment.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.1/Chart.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/patternomaly@1.3.0/dist/patternomaly.min.js"></script>
        <canvas></canvas>
        <script>
        'use strict';
        if (window.__hoc === undefined) {
            window.__hoc = {};
        }
        __hoc.history = (() => {
            Chart.controllers.lineWithCurrent = Chart.controllers.line.extend({
                initialize: function () {
                    Chart.controllers.line.prototype.initialize.apply(this, arguments);
                },
                draw: function (ease) {
                    Chart.controllers.line.prototype.draw.apply(this, arguments);

                    let dataset = this.getDataset();
                    let last = dataset.data[dataset.data.length - 1];
                    if (!last) return;

                    let ctx = this.chart.chart.canvas.getContext('2d');
                    this.chart.chart.canvas.ctx = ctx;
                    ctx.lineWidth = 8;

                    let metaData = this.getMeta().data[this.getMeta().data.length - 1];
                    let x = metaData._model.x;
                    let y = this.calculatePointY(last.y /* * ease XXX (jumps on mouse movement) */);

                    let offsetY = y + ctx.lineWidth / 2;
                    ctx.strokeStyle = metaData._view.backgroundColor;
                    ctx.beginPath();
                    ctx.moveTo(x, offsetY);
                    ctx.lineTo(this.chart.chart.width, offsetY);
                    ctx.stroke();

                    ctx.strokeStyle = metaData._view.borderColor;
                    ctx.lineWidth = metaData._view.borderWidth;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(this.chart.chart.width, y);
                    ctx.stroke();
                }
            });

            // workaround for https://github.com/chartjs/Chart.js/issues/4279#issuecomment-322286138
            function getPattern(color, shape = null) {
              let rgb = Chart.helpers.color(color);
              let bgPattern = shape == null ? pattern.generate([color])[0] : pattern.draw(shape, color);
              return Chart.helpers.extend(bgPattern, {r: rgb.red(), g: rgb.green(), b: rgb.blue(), alpha: rgb.alpha()});
            }

            let chart = new Chart(document.currentScript.previousElementSibling, {
                type: 'lineWithCurrent',
                data: {},
                options: {
                    maintainAspectRatio: false,
                    hover: {
                        mode: 'index',
                        intersect: false
                    },
                    tooltips: {
                        mode: 'index',
                        intersect: false
                    },
                    elements: {
                        line: {
                            stepped: true
                        }
                    },
                    scales: {
                        xAxes: [{
                            type: 'time'
                        }],
                        yAxes: [{
                            ticks: {
                                beginAtZero: true
                            }
                        }]
                    }
                }
            });

            let socket;
            (function connect() {
                socket = new WebSocket('ws://' + location.host + '/ws/status/history');
                socket.onclose = connect;
                socket.onmessage = msg => {
                    let data = JSON.parse(msg.data);
                    switch (data.type) {
                        case 'graph':
                            chart.data.datasets = [];
                            chart.data.datasets.all = data.datasets;
                            chart.data.datasets.all.forEach(it => {
                                chart.data.datasets.push(
                                    Object.assign(
                                        {
                                            // TODO preserve pattern when socket reconnects
                                            backgroundColor: getPattern('hsla(' + Math.floor(360 * Math.random()) + ', 100%, 50%, 0.75)'),
                                            borderColor: 'black',
                                            borderWidth: 1
                                        },
                                        it,
                                        { data: it.data.slice() }
                                    )
                                );
                            });
                            __hoc.history.interval.limit();
                            chart.update();
                            break;
                        case 'graph-update':
                            chart.data.datasets.all.forEach(it => {
                                if (it.label == data.dataset) {
                                    it.data.push(data.datapoint);
                                }
                            });
                            __hoc.history.interval.limit();
                            chart.update();
                            break;
                    }
                };
            })();

            return {
                chart: chart
            };
        })();
        </script>
    </section>

    <form style="text-align: center; margin-bottom: 1em;">
        <span style="float: left;">
            <input type="date" name="start-date"/>
            <input type="time" name="start-time"/>
        </span>

        <h3 style="display: inline;">
            Interval
        </h3>

        <span style="float: right;">
            <input type="date" name="end-date"/>
            <input type="time" name="end-time"/>
        </span>

        <script>
        __hoc.history.interval = (() => {
            let form = document.currentScript.parentElement;

            function limit() {
                let interval = {
                    start: moment(
                        form['start-date'].value +
                        (form['start-time'].value ? 'T' + form['start-time'].value : '')
                    ),
                    end: moment(
                        (form['end-date'].value ? form['end-date'].value : moment().startOf('day')) +
                        'T' +
                        (form['end-time'].value ? form['end-time'].value : '24:00')
                    )
                };

                let chart = __hoc.history.chart;
                chart.data.datasets.forEach(it => it.data = []);
                chart.data.datasets.all.forEach(dataset => {
                    dataset.data
                        .filter(it => {
                            if (interval.start.isValid() && interval.end.isValid())
                                return moment(it.x).isBetween(interval.start, interval.end, null, '[]');
                            else if (interval.start.isValid() && !interval.end.isValid()) {
                                return moment(it.x).isSameOrAfter(interval.start);
                            } else if (!interval.start.isValid() && interval.end.isValid()) {
                                return moment(it.x).isSameOrBefore(interval.end);
                            } else {
                                return true;
                            }
                        })
                        .forEach(point => {
                            chart.data.datasets
                                .filter(it => it.label == dataset.label)
                                .forEach(it => it.data.push(point));
                        });
                });
            }

            function update() {
                limit();
                __hoc.history.chart.update();
            }

            form['start-date'].onchange = event => update();
            form['start-time'].onchange = event => update();
            form['end-date'].onchange   = event => update();
            form['end-time'].onchange   = event => update();

            return {
                limit: limit
            };
        })();
        </script>
    </form>
</article>
